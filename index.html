<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mini Oyunlar - Flappy Bird (Pixel)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2e;
      --text:#e8eefc;
      --muted:#a8b3d6;
      --accent:#59d38b;
      --danger:#ff5c7a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 600px at 20% 0%, #1b2a55 0%, var(--bg) 55%, #070b14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:16px;
    }
    @media (max-width: 900px){
      .app{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .sidebar{ padding:16px; }
    .brand{ display:flex;align-items:center;gap:10px;margin-bottom:14px; }
    .logo{
      width:42px;height:42px;border-radius:12px;
      background: linear-gradient(135deg, #4fd1c5, #59d38b);
      display:grid;place-items:center;
      color:#071013;font-weight:900;
      box-shadow: 0 10px 20px rgba(89,211,139,.25);
    }
    .brand h1{ font-size:18px;line-height:1.1; }
    .brand p{ font-size:12px;color:var(--muted);margin-top:4px; }

    .games{ display:flex;flex-direction:column;gap:10px;margin-top:12px; }
    .gameBtn{
      text-align:left;width:100%;
      padding:12px;border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(17,26,46,.45);
      color:var(--text);
      cursor:pointer;
      display:flex;align-items:center;justify-content:space-between;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    .gameBtn:hover{ transform: translateY(-1px); background: rgba(17,26,46,.70); border-color: rgba(255,255,255,.18); }
    .gameBtn.active{ outline:2px solid rgba(89,211,139,.55); border-color: rgba(89,211,139,.35); }
    .pill{
      font-size:11px;color:#071013;
      background: var(--accent);
      padding:4px 8px;border-radius:999px;font-weight:800;
    }
    .hint{
      margin-top:14px;
      padding:12px;border-radius:14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      color: var(--muted);
      font-size:13px;line-height:1.35;
    }

    .main{ padding:12px; }
    .topbar{
      display:flex;align-items:center;justify-content:space-between;
      padding:12px 12px 8px 12px;
      gap:10px;
      flex-wrap:wrap;
    }
    .title{ display:flex;flex-direction:column;gap:2px; }
    .title b{ font-size:16px; }
    .title span{ font-size:12px;color:var(--muted); }
    .actions{ display:flex;gap:8px;flex-wrap:wrap; }
    .btn{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,26,46,.55);
      color:var(--text);
      padding:9px 10px;border-radius:12px;
      cursor:pointer;
      font-weight:750;font-size:13px;
      transition: background .15s ease, transform .08s ease;
    }
    .btn:hover{ background: rgba(17,26,46,.75); transform: translateY(-1px); }
    .btn.primary{ background: rgba(89,211,139,.18); border-color: rgba(89,211,139,.30); }
    .btn.danger{ background: rgba(255,92,122,.14); border-color: rgba(255,92,122,.28); }

    /* Stage + pixel look */
    .stage{
      margin: 0 12px 12px 12px;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background:#0b1327;
      position:relative;
      user-select:none;
      touch-action: manipulation;
      display:flex;
      justify-content:center;
      align-items:flex-start;

      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    canvas{
      display:block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: linear-gradient(180deg, rgba(0,0,0,.28), rgba(0,0,0,.70));
      opacity:0; pointer-events:none;
      transition: opacity .2s ease;
      padding:14px;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }
    .panel{
      width:min(440px, 96%);
      padding:18px;border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,26,46,.82);
      box-shadow: var(--shadow);
      text-align:center;
    }
    .panel h2{ font-size:18px; margin-bottom:6px;}
    .panel p{ font-size:13px; color:var(--muted); margin-bottom:12px; line-height:1.35;}
    .scoreBig{
      font-size:46px; font-weight:1000;
      letter-spacing:1px;
      margin: 6px 0 10px;
      text-shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    .smallRow{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
    .chip{
      font-size:12px; color:var(--muted);
      padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      min-width: 120px;
    }
    .footerNote{
      text-align:center;
      color: rgba(255,255,255,.35);
      font-size:11px;
      margin-top:8px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card sidebar">
      <div class="brand">
        <div class="logo">ðŸŽ®</div>
        <div>
          <h1>Mini Oyunlar</h1>
          <p>SeÃ§ â†’ Oyna â†’ Skor yap</p>
        </div>
      </div>

      <div class="games">
        <button class="gameBtn active" data-game="flappy">
          <div>
            <div style="font-weight:900">Flappy Bird</div>
            <div style="font-size:12px;color:var(--muted);margin-top:2px;">Pixel (retro) + klasik hissiyat</div>
          </div>
          <span class="pill">OK</span>
        </button>

        <button class="gameBtn" data-game="soon">
          <div>
            <div style="font-weight:900">YakÄ±nda</div>
            <div style="font-size:12px;color:var(--muted);margin-top:2px;">Snake / Tetris / Runnerâ€¦</div>
          </div>
          <span class="pill" style="background:#ffd36b;">SOON</span>
        </button>
      </div>

      <div class="hint">
        <b>Kontroller</b><br/>
        â€¢ <b>Dokun / TÄ±kla / Space</b> = ZÄ±pla<br/>
        â€¢ <b>P</b> = Duraklat<br/>
        â€¢ <b>R</b> = Yeniden baÅŸlat<br/>
        <div style="margin-top:8px;opacity:.9">
          Ä°stersen sonraki oyunu da aynÄ± portal iÃ§ine ekleriz.
        </div>
      </div>
    </div>

    <div class="card main">
      <div class="topbar">
        <div class="title">
          <b id="gameTitle">Flappy Bird (Pixel)</b>
          <span id="gameSubtitle">Dokun / TÄ±kla / Space ile zÄ±pla. Borulara Ã§arpma.</span>
        </div>
        <div class="actions">
          <button class="btn primary" id="btnStart">Start</button>
          <button class="btn" id="btnPause">Pause</button>
          <button class="btn danger" id="btnRestart">Restart</button>
        </div>
      </div>

      <div class="stage" id="stage">
        <canvas id="c"></canvas>

        <div class="overlay show" id="overlay">
          <div class="panel">
            <h2 id="overlayTitle">Flappy Bird</h2>
            <p id="overlayText">
              BaÅŸlamak iÃ§in <b>Dokun / TÄ±kla / Space</b>
            </p>
            <div class="scoreBig" id="bigScore">0</div>
            <div class="smallRow">
              <div class="chip">Best: <b id="bestScore">0</b></div>
              <div class="chip">Mod: <b>Classic</b></div>
              <div class="chip">Kontrol: <b>Tap/Space</b></div>
            </div>
            <div class="smallRow" style="margin-top:12px;">
              <button class="btn primary" id="btnOverlayStart">Start</button>
              <button class="btn" id="btnOverlayRestart">Restart</button>
            </div>
            <div class="footerNote">Pixel mod: dÃ¼ÅŸÃ¼k Ã§Ã¶zÃ¼nÃ¼rlÃ¼k + keskin Ã¶lÃ§ekleme.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Canvas ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const stage = document.getElementById('stage');

  // ---------- UI ----------
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');

  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayText = document.getElementById('overlayText');
  const bigScore = document.getElementById('bigScore');
  const bestScoreEl = document.getElementById('bestScore');
  const btnOverlayStart = document.getElementById('btnOverlayStart');
  const btnOverlayRestart = document.getElementById('btnOverlayRestart');

  // Sidebar (future-proof)
  document.querySelectorAll('.gameBtn').forEach(b=>{
    b.addEventListener('click', () => {
      document.querySelectorAll('.gameBtn').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      if(b.dataset.game !== 'flappy'){
        alert('Bu oyun henÃ¼z eklenmedi ðŸ™‚');
        document.querySelector('[data-game="flappy"]').classList.add('active');
        b.classList.remove('active');
      }
    });
  });

  // ---------- Pixel internal resolution ----------
  const BASE_W = 288;   // classic-ish
  const BASE_H = 512;
  let SCALE = 2;
  let W = BASE_W, H = BASE_H;

  function fitCanvas(){
    const maxW = stage.clientWidth;
    SCALE = Math.max(2, Math.min(5, Math.floor(maxW / BASE_W)));

    W = BASE_W; H = BASE_H;
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = (W * SCALE) + "px";
    canvas.style.height = (H * SCALE) + "px";

    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', fitCanvas, {passive:true});
  fitCanvas();

  // ---------- Game tuning ----------
  const GRAV = 0.42;
  const FLAP = -7.4;
  const MAX_FALL = 10.5;

  const PIPE_SPEED = 2.65;
  const PIPE_GAP = 132;
  const PIPE_W = 78;

  // IMPORTANT: spacing -> pipes won't spawn too close
  const PIPE_SPACING = 170;       // minimum horizontal spacing
  const PIPE_SPAWN_AHEAD = 2;     // keep at least N pipes ahead

  const GROUND_H = 86;
  const BIRD_X = 0.28;

  // ---------- Best score ----------
  const LS_KEY = 'mini_games_flappy_best_pixel';
  let best = Number(localStorage.getItem(LS_KEY) || '0');
  bestScoreEl.textContent = best;

  // ---------- State ----------
  let running = false;
  let paused = false;
  let gameOver = false;

  let score = 0;
  let frame = 0;

  const bird = { x:0, y:0, vy:0, r:14, rot:0 };

  let pipes = [];
  let nextPipeX = 0;

  // Background clouds
  let clouds = [];
  function resetClouds(){
    clouds = [];
    for(let i=0;i<6;i++){
      clouds.push({
        x: Math.random()*W,
        y: 22 + Math.random()*(H-GROUND_H-170),
        s: 1 + Math.floor(Math.random()*2), // integer scale for pixel vibe
        sp: 0.35 + Math.random()*0.55
      });
    }
  }

  function showOverlay(show){
    overlay.classList.toggle('show', show);
  }

  function setOverlay(type){
    if(type === 'start'){
      overlayTitle.textContent = 'Flappy Bird';
      overlayText.innerHTML = 'BaÅŸlamak iÃ§in <b>Dokun / TÄ±kla / Space</b>';
      bigScore.textContent = score;
      showOverlay(true);
      return;
    }
    if(type === 'pause'){
      overlayTitle.textContent = 'DuraklatÄ±ldÄ±';
      overlayText.innerHTML = 'Devam etmek iÃ§in <b>P</b> veya <b>Pause</b>';
      bigScore.textContent = score;
      showOverlay(true);
      return;
    }
    if(type === 'dead'){
      overlayTitle.textContent = 'Game Over';
      overlayText.innerHTML = 'Tekrar dene: <b>Dokun / TÄ±kla / Space</b> veya <b>Restart (R)</b>';
      bigScore.textContent = score;
      showOverlay(true);
      return;
    }
  }

  function randPipeTop(){
    const minTop = 68;
    const maxTop = H - GROUND_H - PIPE_GAP - 110;
    return Math.floor(minTop + Math.random()*(maxTop - minTop));
  }

  function spawnPipe(x){
    pipes.push({ x, top: randPipeTop(), passed:false });
  }

  function ensurePipes(){
    // Guarantee stable spacing and enough pipes ahead
    // Find rightmost pipe x
    let maxX = -Infinity;
    for(const p of pipes) maxX = Math.max(maxX, p.x);

    if(!pipes.length){
      nextPipeX = W + 120;
      maxX = -Infinity;
    }

    // Start nextPipeX from the end
    if(maxX !== -Infinity){
      nextPipeX = Math.max(nextPipeX, maxX + PIPE_SPACING);
    }

    // Keep N pipes ahead beyond screen right edge
    const targetX = W + 120 + (PIPE_SPACING * PIPE_SPAWN_AHEAD);
    while(maxX < targetX){
      const x = (maxX === -Infinity) ? (W + 120) : (maxX + PIPE_SPACING);
      spawnPipe(x);
      maxX = x;
      nextPipeX = maxX + PIPE_SPACING;
    }
  }

  function resetGame(){
    running = false;
    paused = false;
    gameOver = false;
    score = 0;
    frame = 0;

    bird.x = Math.round(W * BIRD_X);
    bird.y = Math.round(H * 0.45);
    bird.vy = 0;
    bird.rot = 0;

    pipes = [];
    nextPipeX = W + 120;
    ensurePipes();

    resetClouds();
    bigScore.textContent = score;

    setOverlay('start');
    render(); // draw once
  }

  function start(){
    if(gameOver){
      resetGame();
    }
    running = true;
    paused = false;
    showOverlay(false);
  }

  function pauseToggle(){
    if(!running || gameOver) return;
    paused = !paused;
    if(paused) setOverlay('pause');
    else showOverlay(false);
  }

  function end(){
    gameOver = true;
    running = false;
    paused = false;

    if(score > best){
      best = score;
      localStorage.setItem(LS_KEY, String(best));
      bestScoreEl.textContent = best;
    }
    setOverlay('dead');
  }

  // ---------- Input ----------
  function flap(){
    if(gameOver){
      start(); // will reset in start()
      bird.vy = FLAP;
      return;
    }
    if(!running){
      start();
      bird.vy = FLAP;
      return;
    }
    if(paused) return;
    bird.vy = FLAP;
  }

  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){ e.preventDefault(); flap(); }
    if(e.code === 'KeyP'){ pauseToggle(); }
    if(e.code === 'KeyR'){ resetGame(); start(); }
  }, {passive:false});

  // IMPORTANT BUG FIX:
  // If overlay is visible, clicking should NOT trigger two events (overlay + stage).
  // We'll handle pointerdown on overlay (buttons already) and stage only when overlay hidden.
  stage.addEventListener('pointerdown', (e)=>{
    // If overlay is shown, let overlay buttons handle it; otherwise flap.
    if(overlay.classList.contains('show')) return;
    e.preventDefault();
    flap();
  }, {passive:false});

  // Overlay: tap anywhere on overlay panel area starts/flaps
  overlay.addEventListener('pointerdown', (e)=>{
    // If clicked on a button, buttons handle it.
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if(tag === 'button') return;
    e.preventDefault();
    flap(); // start + flap
  }, {passive:false});

  btnStart.addEventListener('click', start);
  btnPause.addEventListener('click', pauseToggle);
  btnRestart.addEventListener('click', ()=>{ resetGame(); start(); });

  btnOverlayStart.addEventListener('click', ()=>{ start(); });
  btnOverlayRestart.addEventListener('click', ()=>{ resetGame(); start(); });

  // ---------- Collision ----------
  function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  // ---------- Update ----------
  function update(){
    if(!running || paused || gameOver) return;

    frame++;

    // clouds
    for(const cl of clouds){
      cl.x -= cl.sp * 0.4;
      if(cl.x < -90){
        cl.x = W + 90;
        cl.y = 22 + Math.random()*(H-GROUND_H-170);
        cl.s = 1 + Math.floor(Math.random()*2);
        cl.sp = 0.35 + Math.random()*0.55;
      }
    }

    // bird physics
    bird.vy += GRAV;
    if(bird.vy > MAX_FALL) bird.vy = MAX_FALL;
    bird.y += bird.vy;

    const targetRot = Math.max(-0.55, Math.min(1.25, bird.vy / 10));
    bird.rot += (targetRot - bird.rot) * 0.18;

    // pipes move
    for(const p of pipes){
      p.x -= PIPE_SPEED;

      // score pass (use pipe center)
      if(!p.passed && (p.x + PIPE_W) < bird.x){
        p.passed = true;
        score++;
      }
    }

    // remove off-screen pipes
    while(pipes.length && pipes[0].x < -PIPE_W - 10){
      pipes.shift();
    }

    // ensure stable spacing ahead
    ensurePipes();

    // collisions
    const groundY = H - GROUND_H;
    if(bird.y + bird.r >= groundY){
      bird.y = groundY - bird.r;
      end();
      return;
    }
    if(bird.y - bird.r <= 0){
      bird.y = bird.r;
      end();
      return;
    }

    const hitR = bird.r - 2;
    for(const p of pipes){
      const gapTop = p.top;
      const gapBottom = p.top + PIPE_GAP;

      // top pipe
      if(circleRectCollide(bird.x, bird.y, hitR, p.x, -1000, PIPE_W, 1000 + gapTop) ||
         circleRectCollide(bird.x, bird.y, hitR, p.x, gapBottom, PIPE_W, (groundY - gapBottom))){
        end();
        return;
      }
    }
  }

  // ---------- Render ----------
  function drawSky(){
    // simple pixel-friendly sky fill
    ctx.fillStyle = '#78d6ff';
    ctx.fillRect(0,0,W,H);

    // sun
    ctx.fillStyle = 'rgba(255,245,180,.95)';
    ctx.fillRect(W-48, 22, 18, 18);
    ctx.fillRect(W-66, 30, 18, 18);
    ctx.fillRect(W-56, 44, 18, 18);

    // clouds (blocky)
    ctx.fillStyle = 'rgba(255,255,255,.85)';
    for(const cl of clouds){
      const x = Math.round(cl.x), y = Math.round(cl.y), s = cl.s;
      blockCloud(x, y, s);
    }

    // hills
    ctx.fillStyle = '#57d46f';
    ctx.fillRect(0, H-GROUND_H-58, W, 18);
    ctx.fillStyle = '#45bf63';
    ctx.fillRect(0, H-GROUND_H-40, W, 22);

    function blockCloud(x,y,s){
      // 5 blocks
      ctx.fillRect(x, y, 22*s, 10*s);
      ctx.fillRect(x+10*s, y-6*s, 20*s, 10*s);
      ctx.fillRect(x+24*s, y, 24*s, 10*s);
      ctx.fillRect(x+14*s, y+6*s, 22*s, 10*s);
      ctx.fillRect(x+36*s, y+6*s, 18*s, 10*s);
    }
  }

  function drawPipes(){
    const groundTop = H - GROUND_H;
    for(const p of pipes){
      const x = Math.round(p.x);
      const top = p.top;
      const gapBottom = top + PIPE_GAP;

      drawPipe(x, top, true);
      drawPipe(x, gapBottom, false);

      function drawPipe(x, y, isTop){
        const bodyColor = '#35d85b';
        const dark = '#1fb84a';
        const edge = '#137a2f';

        let ry, rh;
        if(isTop){
          ry = -900;
          rh = 900 + y;
        }else{
          ry = y;
          rh = (groundTop - y);
        }

        // body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(x, ry, PIPE_W, rh);

        // shading
        ctx.fillStyle = dark;
        ctx.fillRect(x+8, ry, 10, rh);
        ctx.fillRect(x+PIPE_W-16, ry, 8, rh);

        // outline (pixel)
        ctx.fillStyle = edge;
        ctx.fillRect(x, ry, PIPE_W, 2);
        ctx.fillRect(x, ry+rh-2, PIPE_W, 2);
        ctx.fillRect(x, ry, 2, rh);
        ctx.fillRect(x+PIPE_W-2, ry, 2, rh);

        // cap
        const capH = 16;
        const capW = PIPE_W + 10;
        const capX = x - 5;
        const capY = isTop ? (y - capH) : y;

        ctx.fillStyle = bodyColor;
        ctx.fillRect(capX, capY, capW, capH);

        ctx.fillStyle = edge;
        ctx.fillRect(capX, capY, capW, 2);
        ctx.fillRect(capX, capY+capH-2, capW, 2);
        ctx.fillRect(capX, capY, 2, capH);
        ctx.fillRect(capX+capW-2, capY, 2, capH);

        // highlight
        ctx.fillStyle = 'rgba(255,255,255,.22)';
        ctx.fillRect(capX+4, capY+3, capW-8, 2);
      }
    }
  }

  function drawGround(){
    const y = H - GROUND_H;
    ctx.fillStyle = '#e6d36a';
    ctx.fillRect(0, y, W, GROUND_H);

    ctx.fillStyle = '#58d86d';
    ctx.fillRect(0, y, W, 14);

    const stripeW = 18;
    const offset = Math.floor((frame * PIPE_SPEED) % stripeW);
    ctx.fillStyle = 'rgba(0,0,0,.10)';
    for(let x = -offset; x < W + stripeW; x += stripeW){
      ctx.fillRect(x, y+18, Math.floor(stripeW/2), GROUND_H-18);
    }
  }

  function drawBird(){
    const px = 1;
    ctx.save();
    ctx.translate(Math.round(bird.x), Math.round(bird.y));
    ctx.rotate(bird.rot);

    const ox = -8, oy = -6;

    // Body sprite (pixel)
    ctx.fillStyle = '#ffd24a';
    const body = [
      "0011111100000000",
      "0111111111000000",
      "1111111111100000",
      "1111111111110000",
      "1111111111110000",
      "0111111111110000",
      "0011111111100000",
      "0001111110000000",
      "0000111100000000",
      "0000011000000000",
      "0000000000000000",
      "0000000000000000",
    ];
    for (let y=0; y<body.length; y++){
      for (let x=0; x<body[y].length; x++){
        if(body[y][x] === "1"){
          ctx.fillRect(ox + x*px, oy + y*px, px, px);
        }
      }
    }

    // Beak
    ctx.fillStyle = '#ff8a3d';
    ctx.fillRect(ox + 12, oy + 5, 3, 2);
    ctx.fillRect(ox + 14, oy + 4, 2, 4);

    // Eye
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(ox + 9, oy + 3, 2, 2);
    ctx.fillStyle = '#1c2230';
    ctx.fillRect(ox + 10, oy + 4, 1, 1);

    // Wing
    ctx.fillStyle = '#f4b83b';
    ctx.fillRect(ox + 5, oy + 6, 3, 2);
    ctx.fillRect(ox + 4, oy + 7, 4, 2);

    ctx.restore();
  }

  function drawScore(){
    // pixel-friendly score (block digits)
    const s = String(score);
    const digitW = 14, digitH = 20, gap = 3;
    const totalW = s.length * digitW + (s.length-1)*gap;
    let x = Math.floor(W/2 - totalW/2);
    const y = 12;

    for(const ch of s){
      drawDigit(x, y, ch);
      x += digitW + gap;
    }

    function drawDigit(x,y,d){
      // 3x5 pixel font scaled
      const map = {
        "0":[ "111","101","101","101","111" ],
        "1":[ "010","110","010","010","111" ],
        "2":[ "111","001","111","100","111" ],
        "3":[ "111","001","111","001","111" ],
        "4":[ "101","101","111","001","001" ],
        "5":[ "111","100","111","001","111" ],
        "6":[ "111","100","111","101","111" ],
        "7":[ "111","001","001","001","001" ],
        "8":[ "111","101","111","101","111" ],
        "9":[ "111","101","111","001","111" ]
      };
      const rows = map[d] || map["0"];
      const scale = 4; // 3*4=12 wide
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      draw(rows, x+2, y+2, scale);
      ctx.fillStyle = '#ffffff';
      draw(rows, x, y, scale);

      function draw(rows, x0, y0, sc){
        for(let ry=0; ry<rows.length; ry++){
          for(let rx=0; rx<rows[ry].length; rx++){
            if(rows[ry][rx] === "1"){
              ctx.fillRect(x0 + rx*sc, y0 + ry*sc, sc, sc);
            }
          }
        }
      }
    }
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    drawSky();
    drawPipes();
    drawGround();
    drawBird();
    drawScore();
  }

  function loop(){
    update();
    render();
    requestAnimationFrame(loop);
  }

  // ---------- Init ----------
  resetGame();
  loop();
})();
</script>
</body>
</html>
